name: Deploy to Azure Container Apps

on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

env:
  AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
  AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
  AZURE_ACR_NAME: ${{ vars.AZURE_ACR_NAME }}
  AZURE_APP_NAME: ${{ vars.AZURE_APP_NAME }}
  AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME }}
  AZURE_LOG_ANALYTICS_NAME: ${{ vars.AZURE_LOG_ANALYTICS_NAME }}
  AZURE_STORAGE_ACCOUNT_NAME: ${{ vars.AZURE_STORAGE_ACCOUNT_NAME }}
  AZURE_RESOURCE_NAME: ${{ vars.AZURE_RESOURCE_NAME }}
  AZURE_MODEL: ${{ vars.AZURE_MODEL || 'azure/gpt-5.2-chat' }}
  DATA_SHARE_NAME: ${{ vars.DATA_SHARE_NAME || 'quillbot-data' }}
  CONFIG_SHARE_NAME: ${{ vars.CONFIG_SHARE_NAME || 'opencode-config' }}
  WEB_IMAGE_NAME: ${{ vars.WEB_IMAGE_NAME || 'quillbot-web' }}
  OPENCODE_IMAGE_NAME: ${{ vars.OPENCODE_IMAGE_NAME || 'quillbot-opencode' }}
  OPENCODE_VERSION: ${{ vars.OPENCODE_VERSION || 'latest' }}
  IMAGE_TAG: ${{ github.sha }}
  # Easy Auth configuration (Microsoft Entra ID)
  ENTRA_CLIENT_ID: ${{ vars.ENTRA_CLIENT_ID }}
  ENTRA_TENANT_ID: ${{ vars.ENTRA_TENANT_ID }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure Resource Group
        run: az group create --name "$AZURE_RESOURCE_GROUP" --location "$AZURE_LOCATION"

      - name: Ensure ACR and fetch credentials
        id: acr
        run: |
          if ! az acr show --name "$AZURE_ACR_NAME" --resource-group "$AZURE_RESOURCE_GROUP" > /dev/null 2>&1; then
            az acr create \
              --name "$AZURE_ACR_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --location "$AZURE_LOCATION" \
              --sku Basic \
              --admin-enabled true
          else
            az acr update --name "$AZURE_ACR_NAME" --admin-enabled true
          fi
          LOGIN_SERVER=$(az acr show --name "$AZURE_ACR_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query loginServer -o tsv)
          USERNAME=$(az acr credential show --name "$AZURE_ACR_NAME" --query username -o tsv)
          PASSWORD=$(az acr credential show --name "$AZURE_ACR_NAME" --query "passwords[0].value" -o tsv)
          echo "loginServer=$LOGIN_SERVER" >> "$GITHUB_OUTPUT"
          echo "username=$USERNAME" >> "$GITHUB_OUTPUT"
          echo "password=$PASSWORD" >> "$GITHUB_OUTPUT"

      - name: Docker login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.acr.outputs.loginServer }}
          username: ${{ steps.acr.outputs.username }}
          password: ${{ steps.acr.outputs.password }}

      - name: Build and push Web image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: containers/web/Dockerfile
          push: true
          tags: ${{ steps.acr.outputs.loginServer }}/${{ env.WEB_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Build and push OpenCode image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: containers/opencode/Dockerfile
          push: true
          build-args: |
            OPENCODE_VERSION=${{ env.OPENCODE_VERSION }}
          tags: ${{ steps.acr.outputs.loginServer }}/${{ env.OPENCODE_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Ensure infrastructure and file shares
        run: |
          az deployment group create \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --template-file infra/azure/main.bicep \
            --parameters \
              deployApp=false \
              location="$AZURE_LOCATION" \
              appName="$AZURE_APP_NAME" \
              environmentName="$AZURE_ENV_NAME" \
              logAnalyticsName="$AZURE_LOG_ANALYTICS_NAME" \
              acrName="$AZURE_ACR_NAME" \
              storageAccountName="$AZURE_STORAGE_ACCOUNT_NAME" \
              dataShareName="$DATA_SHARE_NAME" \
              configShareName="$CONFIG_SHARE_NAME"

      - name: Upload OpenCode config to Azure Files
        run: |
          echo "Uploading config files to Azure Files..."
          chmod +x scripts/upload-config-to-azure.sh
          ./scripts/upload-config-to-azure.sh "$AZURE_STORAGE_ACCOUNT_NAME" "$CONFIG_SHARE_NAME"

      - name: Update Container App secrets
        env:
          OPENCODE_API_KEY: ${{ secrets.OPENCODE_API_KEY }}
          AZURE_API_KEY: ${{ secrets.AZURE_API_KEY }}
        run: |
          if ! az containerapp show --name "$AZURE_APP_NAME" --resource-group "$AZURE_RESOURCE_GROUP" > /dev/null 2>&1; then
            echo "Container App not created yet; secrets will be applied during deployment"
            exit 0
          fi

          SECRET_ARGS=()
          if [ -n "$OPENCODE_API_KEY" ]; then
            SECRET_ARGS+=("opencode-api-key=$OPENCODE_API_KEY")
          fi
          if [ -n "$AZURE_API_KEY" ]; then
            SECRET_ARGS+=("azure-api-key=$AZURE_API_KEY")
          fi

          if [ ${#SECRET_ARGS[@]} -eq 0 ]; then
            echo "No non-empty secrets configured; skipping secret update"
            exit 0
          fi

          az containerapp secret set \
            --name "$AZURE_APP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --secrets "${SECRET_ARGS[@]}"

      - name: Deploy/Update Container App revision
        run: |
          WEB_IMAGE="${{ steps.acr.outputs.loginServer }}/${WEB_IMAGE_NAME}:${IMAGE_TAG}"
          OPENCODE_IMAGE="${{ steps.acr.outputs.loginServer }}/${OPENCODE_IMAGE_NAME}:${IMAGE_TAG}"
          CONFIG_REV="${IMAGE_TAG}-${GITHUB_RUN_NUMBER}"

          az deployment group create \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --template-file infra/azure/main.bicep \
            --parameters \
              deployApp=true \
              location="$AZURE_LOCATION" \
              appName="$AZURE_APP_NAME" \
              environmentName="$AZURE_ENV_NAME" \
              logAnalyticsName="$AZURE_LOG_ANALYTICS_NAME" \
              acrName="$AZURE_ACR_NAME" \
              storageAccountName="$AZURE_STORAGE_ACCOUNT_NAME" \
              dataShareName="$DATA_SHARE_NAME" \
              configShareName="$CONFIG_SHARE_NAME" \
              webImage="$WEB_IMAGE" \
              opencodeImage="$OPENCODE_IMAGE" \
              configRevision="$CONFIG_REV" \
              azureResourceName="$AZURE_RESOURCE_NAME" \
              azureModel="$AZURE_MODEL" \
              opencodeApiKey="${{ secrets.OPENCODE_API_KEY }}" \
              azureApiKey="${{ secrets.AZURE_API_KEY }}"

      - name: Configure Easy Auth (Microsoft Entra ID)
        if: ${{ env.ENTRA_CLIENT_ID != '' && env.ENTRA_TENANT_ID != '' }}
        run: |
          echo "Configuring Easy Auth with Microsoft Entra ID..."

          # Check if auth is already configured
          AUTH_ENABLED=$(az containerapp auth show \
            --name "$AZURE_APP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --query "platform.enabled" -o tsv 2>/dev/null || echo "false")

          if [ "$AUTH_ENABLED" != "true" ]; then
            echo "Enabling Easy Auth..."
            az containerapp auth microsoft update \
              --name "$AZURE_APP_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --client-id "$ENTRA_CLIENT_ID" \
              --issuer "https://sts.windows.net/${ENTRA_TENANT_ID}/v2.0" \
              --yes
            
            # Set unauthenticated action to redirect to login
            az containerapp auth update \
              --name "$AZURE_APP_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --unauthenticated-client-action RedirectToLoginPage \
              --redirect-provider azureactivedirectory
            
            echo "Easy Auth configured successfully"
          else
            echo "Easy Auth already enabled, skipping configuration"
          fi

      - name: Health check
        run: |
          FQDN=$(az containerapp show \
            --name "$AZURE_APP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --query "properties.configuration.ingress.fqdn" -o tsv)

          if [ -z "$FQDN" ]; then
            echo "No ingress FQDN found for container app"
            exit 1
          fi

          for attempt in {1..20}; do
            STATUS=$(az containerapp show \
              --name "$AZURE_APP_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --query "properties.runningStatus" -o tsv)
            if [ "$STATUS" = "Running" ]; then
              break
            fi
            echo "Waiting for Running status (attempt $attempt/20): $STATUS"
            sleep 15
          done

          STATUS=$(az containerapp show \
            --name "$AZURE_APP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --query "properties.runningStatus" -o tsv)
          if [ "$STATUS" != "Running" ]; then
            echo "Container app is not Running (status: $STATUS)"
            exit 1
          fi

          HTTP_CODE=$(curl -sS -L -o /dev/null -w "%{http_code}" "https://$FQDN")
          case "$HTTP_CODE" in
            200|302|401)
              echo "Health probe returned HTTP $HTTP_CODE"
              ;;
            *)
              echo "Unexpected health probe code: $HTTP_CODE"
              exit 1
              ;;
          esac
